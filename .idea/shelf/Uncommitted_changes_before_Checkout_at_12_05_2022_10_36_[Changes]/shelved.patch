Index: game.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import copy as copy\r\nimport random\r\nimport sys\r\nimport time\r\n\r\nimport numpy as np\r\nimport pygame as pg\r\n\r\ngraphic_on = True\r\nfps = 60\r\nreal_tile_size = 16\r\nscale = 4\r\ntile_size = real_tile_size * scale\r\ngrid_size_x = int(64 / scale)\r\ngrid_size_y = int(64 / scale)\r\nscreen_size_x = grid_size_x * tile_size\r\nscreen_size_y = grid_size_y * tile_size\r\nscore = 0\r\nif graphic_on:\r\n    screen = pg.display.set_mode((screen_size_x, screen_size_y))\r\n    pg.display.set_caption(\"snake\")\r\n    background = pg.image.load('../Snake-AI/sprites/white.png').convert()\r\n    background = pg.transform.scale(background, (tile_size, tile_size))\r\n    pg.init()\r\nnumber_of_fruits = 1\r\n\r\nkeys = []\r\nclock = pg.time.Clock()\r\n\r\n\r\ndef get_input(run):\r\n    for event in pg.event.get():\r\n        if event.type == pg.QUIT:\r\n            run = False\r\n        if event.type == pg.KEYDOWN:\r\n            if event.key == pg.K_s:\r\n                keys.append('s')\r\n            if event.key == pg.K_w:\r\n                keys.append('w')\r\n            if event.key == pg.K_d:\r\n                keys.append('d')\r\n            if event.key == pg.K_a:\r\n                keys.append('a')\r\n    return run\r\n\r\n\r\ndef draw_score():\r\n    font = pg.font.SysFont(None, int(tile_size))\r\n    img = font.render(str(len(snake.body)), True, 'BLACK')\r\n    screen.blit(img, (20, 20))\r\n\r\n\r\ndef state_of_game():\r\n    global snake\r\n    d_up, d_down, d_left, d_right = snake.danger_detection()\r\n    m_up, m_down, m_left, m_right = snake.direction_detection()\r\n    f_up, f_down, f_left, f_right = snake.fruits_detection()\r\n    #print(snake.direction_detection())\r\n    #print(m_up,m_down,m_left,m_right)\r\n    if m_up == 1:\r\n        state = [d_up, d_right, d_left,\r\n                m_up, m_down, m_left, m_right,\r\n                f_up, f_down, f_left, f_right]\r\n    if m_down == 1:\r\n        state = [d_down, d_left, d_right,\r\n                m_up, m_down, m_left, m_right,\r\n                f_up, f_down, f_left, f_right]\r\n    if m_left == 1:\r\n        state = [d_left, d_up, d_down,\r\n                m_up, m_down, m_left, m_right,\r\n                f_up, f_down, f_left, f_right]\r\n    if m_right == 1:\r\n        state = [d_right, d_down, d_up,\r\n                m_up, m_down, m_left, m_right,\r\n                f_up, f_down, f_left, f_right]\r\n    return state\r\n\r\n\r\nclass Fruit:\r\n    def __init__(self):\r\n        self.location = [-1, -1]\r\n        if graphic_on:\r\n            self.sprite = pg.image.load('../Snake-AI/sprites/fruit.png')\r\n            self.sprite = pg.transform.scale(self.sprite, (tile_size, tile_size))\r\n            self.sound = pg.mixer.Sound('../Snake-AI/sounds/fruit.mp3')\r\n            self.sound.set_volume(0.3)\r\n\r\n    def generate(self, snake_body):\r\n        self.location = [random.randrange(0, grid_size_x), random.randrange(0, grid_size_y)]\r\n        for body_part in snake_body:\r\n            if body_part == self.location:\r\n                self.location = self.generate(snake_body)\r\n        return self.location\r\n\r\n    def draw(self):\r\n        screen.blit(self.sprite, (self.location[0] * tile_size, self.location[1] * tile_size))\r\n\r\n\r\nclass Snake:\r\n    def __init__(self):\r\n        self.pos_x = random.randrange(0, grid_size_x - 1)\r\n        self.pos_y = random.randrange(0, grid_size_y - 1)\r\n        self.body = [[-1, -1]]\r\n        if graphic_on:\r\n            self.head_sprite = pg.image.load('../Snake-AI/sprites/snek.png').convert()\r\n            self.head_sprite = pg.transform.scale(self.head_sprite, (tile_size, tile_size))\r\n            self.body_sprite = pg.image.load('../Snake-AI/sprites/body.png').convert()\r\n            self.body_sprite = pg.transform.scale(self.body_sprite, (tile_size, tile_size))\r\n        self.rotation = 0\r\n        self.direction = random.randint(1, 4)\r\n        self.is_alive = True\r\n\r\n    def direction_detection(self):\r\n        up = 0\r\n        down = 0\r\n        left = 0\r\n        right = 0\r\n        if self.direction == 1:\r\n            left = 1\r\n        if self.direction == 2:\r\n            right = 1\r\n        if self.direction == 3:\r\n            down = 1\r\n        if self.direction == 4:\r\n            up = 1\r\n        return up, down, left, right\r\n\r\n    def movement(self):\r\n        if self.direction == 1:\r\n            self.pos_x = self.pos_x - 1\r\n        if self.direction == 2:\r\n            self.pos_x = self.pos_x + 1\r\n        if self.direction == 3:\r\n            self.pos_y = self.pos_y - 1\r\n        if self.direction == 4:\r\n            self.pos_y = self.pos_y + 1\r\n\r\n    def pos_correction(self):\r\n        if self.pos_y > grid_size_y - 1:\r\n            self.pos_y = 0\r\n        if self.pos_y < 0:\r\n            self.pos_y = grid_size_y - 1\r\n\r\n        if self.pos_x > grid_size_x - 1:\r\n            self.pos_x = 0\r\n        if self.pos_x < 0:\r\n            self.pos_x = grid_size_x - 1\r\n\r\n    def danger_detection(self):\r\n        up = 0\r\n        down = 0\r\n        left = 0\r\n        right = 0\r\n        for body_part in range(1, len(self.body)):\r\n            if abs(self.pos_x - self.body[body_part][0]) <= 1 and abs(self.pos_y - self.body[body_part][1]) <= 1:\r\n                if self.pos_x - self.body[body_part][0] == 0:\r\n                    if self.body[body_part][1] > self.pos_y:\r\n                        up = 1\r\n                    else:\r\n                        down = 0\r\n                if self.pos_y - self.body[body_part][1] == 0:\r\n                    if self.body[body_part][0] > self.pos_x:\r\n                        right = 0\r\n                    else:\r\n                        left = 0\r\n        return up, down, left, right\r\n\r\n    def fruits_detection(self):\r\n        global fruits\r\n        fruit = fruits['fruit ' + str(0)]\r\n        fruit_x = fruit.location[0]\r\n        fruit_y = fruit.location[1]\r\n        up = 0\r\n        down = 0\r\n        left = 0\r\n        right = 0\r\n        if fruit_x > self.pos_x:\r\n            right = 1\r\n        elif fruit_x < self.pos_x:\r\n            left = 1\r\n        if fruit_y > self.pos_y:\r\n            up = 1\r\n        elif fruit_y < self.pos_y:\r\n            down = 1\r\n        return up, down, left, right\r\n\r\n    def collision_body(self):\r\n        if len(self.body) > 0:\r\n            for body_part in range(1, len(self.body)):\r\n                if self.body[body_part] == [self.pos_x, self.pos_y]:\r\n                    self.is_alive = False\r\n\r\n    def collision_fruit(self, Fruit):\r\n        global reward\r\n        if [self.pos_x, self.pos_y] == Fruit.location:\r\n            self.body.append([-1, -1])\r\n            reward += 10\r\n            if graphic_on:\r\n                Fruit.sound.play()\r\n            Fruit.location = Fruit.generate(self.body)\r\n        return Fruit.location\r\n\r\n    def tail_update(self):\r\n        if len(self.body) > 0:\r\n            for body_part in range(len(self.body) - 1, -1, -1):\r\n                self.body[body_part] = self.body[body_part - 1]\r\n        self.body[0] = copy.copy([self.pos_x, self.pos_y])\r\n\r\n    def handle_input(self, keys):\r\n        if keys[0] == 'a' and self.direction != 2:\r\n            self.direction = 1\r\n            if graphic_on:\r\n                self.head_sprite = pg.transform.rotate(self.head_sprite, self.rotation - 270)\r\n            self.rotation = 270\r\n            return\r\n        if keys[0] == 'd' and self.direction != 1:\r\n            self.direction = 2\r\n            if graphic_on:\r\n                self.head_sprite = pg.transform.rotate(self.head_sprite, self.rotation - 90)\r\n            self.rotation = 90\r\n            return\r\n        if keys[0] == 'w' and self.direction != 4:\r\n            self.direction = 3\r\n            if graphic_on:\r\n                self.head_sprite = pg.transform.rotate(self.head_sprite, self.rotation)\r\n            self.rotation = 0\r\n            return\r\n        if keys[0] == 's' and self.direction != 3:\r\n            self.direction = 4\r\n            if graphic_on:\r\n                self.head_sprite = pg.transform.rotate(self.head_sprite, self.rotation - 180)\r\n            self.rotation = 180\r\n            return\r\n\r\n    def draw(self):\r\n        if len(self.body) > 0:\r\n            for body_part in range(1, len(self.body)):\r\n                screen.blit(self.body_sprite,\r\n                            (self.body[body_part][0] * tile_size, self.body[body_part][1] * tile_size))\r\n        screen.blit(self.head_sprite, (self.pos_x * tile_size, self.pos_y * tile_size))\r\n\r\n    def update(self, keys):\r\n        if len(keys) >= 1:\r\n            self.handle_input(keys)\r\n        self.movement()\r\n        self.pos_correction()\r\n        self.tail_update()\r\n        self.collision_body()\r\n\r\n\r\nsnake = Snake()\r\nfruits = {}\r\ntick = int(fps / 10)\r\n\r\n\r\ndef restart():\r\n    global snake\r\n    global fruits\r\n    global running\r\n    global keys\r\n    keys = []\r\n    if graphic_on:\r\n        pg.init()\r\n    running = False\r\n    snake = Snake()\r\n    fruits = {}\r\n    for x in range(0, number_of_fruits):\r\n        fruits['fruit ' + str(x)] = Fruit()\r\n        fruits['fruit ' + str(x)].generate(snake.body)\r\n\r\n\r\nrunning = True\r\n\r\n\r\ndef Score():\r\n    global score\r\n    return score\r\n\r\ndef Reward():\r\n    global reward\r\n    return reward\r\n\r\ndef key_pressed(move):\r\n    global snake\r\n    #print(move)\r\n    if snake.direction == 1:\r\n        if move[0] == 1:\r\n            return 'a'\r\n        if move[1] == 1:\r\n            return 'w'\r\n        if move[2] == 1:\r\n            return's'\r\n    if snake.direction == 2:\r\n        if move[0] == 1:\r\n            return 'd'\r\n        if move[1] == 1:\r\n            return 's'\r\n        if move[2] == 1:\r\n            return 'w'\r\n    if snake.direction == 3:\r\n        if move[0] == 1:\r\n            return 's'\r\n        if move[1] == 1:\r\n            return 'a'\r\n        if move[2] == 1:\r\n            return 'd'\r\n    if snake.direction == 4:\r\n        if move[0] == 1:\r\n            return 'w'\r\n        if move[1] == 1:\r\n            return 'd'\r\n        if move[2] == 1:\r\n            return 'a'\r\n\r\nreward = 0\r\ndef next_frame(final_move):\r\n    global tick\r\n    global snake\r\n    global running\r\n    global score\r\n    global keys\r\n    # print(keys)\r\n    global reward\r\n    reward = 0\r\n    if not running:\r\n        if graphic_on:\r\n            screen.fill((255, 255, 255))\r\n        # running = get_input(running)\r\n        snake.update(key_pressed(final_move))\r\n        # print(keys)\r\n        # if len(keys) >= 1:\r\n        #    keys.pop(0)\r\n        if graphic_on:\r\n            snake.draw()\r\n        dangers = state_of_game()\r\n        print('up: ', dangers[0],'Right:', dangers[1], \"left\", dangers[2])\r\n\r\n        for x in range(0, number_of_fruits):\r\n            fruits['fruit ' + str(x)].location = snake.collision_fruit(fruits['fruit ' + str(x)])\r\n            if graphic_on:\r\n                fruits['fruit ' + str(x)].draw()\r\n        tick = 0\r\n        score = len(snake.body)\r\n        if graphic_on:\r\n            draw_score()\r\n            pg.display.update()\r\n        clock.tick(fps)\r\n        if not snake.is_alive:\r\n            running = True\r\n            reward -= 10\r\n        pg.time.wait(400)\r\n    return running\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game.py b/game.py
--- a/game.py	(revision 2e9718e847df3c7741fbe5d91b554d5273a4be55)
+++ b/game.py	(date 1652344401842)
@@ -157,12 +157,12 @@
                     if self.body[body_part][1] > self.pos_y:
                         up = 1
                     else:
-                        down = 0
+                        down = 1
                 if self.pos_y - self.body[body_part][1] == 0:
                     if self.body[body_part][0] > self.pos_x:
-                        right = 0
+                        right = 1
                     else:
-                        left = 0
+                        left = 1
         return up, down, left, right
 
     def fruits_detection(self):
@@ -332,21 +332,19 @@
         #    keys.pop(0)
         if graphic_on:
             snake.draw()
-        dangers = state_of_game()
-        print('up: ', dangers[0],'Right:', dangers[1], "left", dangers[2])
+        #dangers = state_of_game()
+        #print('up: ', dangers[0],'Right:', dangers[1], "left", dangers[2])
 
         for x in range(0, number_of_fruits):
             fruits['fruit ' + str(x)].location = snake.collision_fruit(fruits['fruit ' + str(x)])
             if graphic_on:
                 fruits['fruit ' + str(x)].draw()
-        tick = 0
         score = len(snake.body)
         if graphic_on:
             draw_score()
             pg.display.update()
-        clock.tick(fps)
+        #clock.tick(fps)
         if not snake.is_alive:
             running = True
             reward -= 10
-        pg.time.wait(400)
     return running
